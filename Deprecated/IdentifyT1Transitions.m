% This script identifies the occurence of T1 transitions from connectivity
% information in the detailed output files generated by Epi-Scale.

% clear all

%% Parameter Declaration
relevantSimulations = { 'GrowthConstant_0.3'	, ...
    'GrowthConstant_0.4'    , ...
    'GrowthConstant_0.5'    , ...
    'GrowthConstant_0.6'    , ...
    'GrowthConstant_0.7'    };

lagAfterDetection = 2; % How many timesteps after a T1 transition can another be registered?

%% Initialization
settings = prepareWorkspace();
[labels, labelIndices] = getLabels(settings.inDetailsDir, relevantSimulations, 2);
simulationNumber = length(labels);

for i = unique(labelIndices)
    disp([num2str(sum(labelIndices==i)) ' simulations for condition #' num2str(i)])
end

outT1s = zeros(simulationNumber,2000); % When T1s Happen
outN = zeros(simulationNumber,2000); % Whether Time Was Analyzed
outCellNumber = zeros(simulationNumber,2000); % Total Number of Cells
outPosition = cell(simulationNumber,2000);
outT1Position = cell(simulationNumber,2000);
outLabelIndices = labelIndices;

%% Analysis
for i = 1:length(labels)
    cellNumber = 0;
    for t = 1:2000
        %% Extract Data
        currentFilename = [settings.inDetailsDir processDatafileName(labels{i}, t)];
        
        % If the file doesn't exist, then the simulation continues to the
        % next file in the list.
        if exist(currentFilename, 'file') ~= 2
            break
        end
        if mod(t,100) == 0
            disp(['Simulation: ' num2str(i) ' of ' num2str(length(labels)) ' time = ' num2str(t) '  simulation:' labels{i}])
        end
        
        cellData = parseDatafile(currentFilename);
        
        newCellNumber = length(cellData);
        
        % Check to make sure data was not corrupted, since cells are not
        % destroyed in this simulation.
        if newCellNumber < cellNumber
            break
        end
        
        edgeCell = str2double({cellData.IsBoundrayCell});
        growthProgress = str2double({cellData.GrowthProgress});
        
        newAdjacencyMatrix = makeAdjacencyMatrix({cellData.NeighborCells});
        [rTemp, ~] = parseCellPositionString({cellData.CellCenter});
        outPosition{i,t} = rTemp;
        
        if cellNumber > 0
            
            neighborChanges = newAdjacencyMatrix(1:cellNumber,1:cellNumber) - adjacencyMatrix(1:cellNumber,1:cellNumber);
            % is and js are cells which gained a neighbor
            [is, js] = find(neighborChanges > 0);
            
            T1 = 0;
            
            tempPositions = [];
            for n = 1:length(is)
                x = is(n);
                y = js(n);
                
                if ~isnan(edgeCell(x)) && ~isnan(edgeCell(y)) && ...
                        ~edgeCell(x) && ~edgeCell(y) &&  x < y && ...
                        growthProgress(x) < 0.91 && growthProgress(y) < 0.91 && ...
                        growthProgress(x) > 0.03 && growthProgress(y) > 0.03 && ...
                        trackedCells(x) <= 0 && trackedCells(y) <= 0
                    T1 = T1 + 1;
                    tempPositions = [tempPositions rTemp(x) rTemp(y)];
                    trackedCells(x) = lagAfterDetection;
                    trackedCells(y) = lagAfterDetection;
                end
                outT1Position{i,t} = tempPositions;
            end
            outT1s(i,t) = T1;
        end
        
        trackedCells((cellNumber+1):newCellNumber) = lagAfterDetection;
        trackedCells = trackedCells - 1;
        
        
        cellNumber = newCellNumber;
        adjacencyMatrix = newAdjacencyMatrix;
        
        outCellNumber(i,t) = newCellNumber;
        outN(i,t) = 1;
    end
end

save('dataDump')